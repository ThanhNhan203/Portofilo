{
    "Java": [
      {
        
            "title": "Java Naming Convention",
            "date": "09/05/2022",
            "image": "assets/images/java1.jpg",
            "category": "Java Object Class",
            "content":"    Lorem Ipsum chỉ đơn giản là văn bản giả của ngành in ấn và sắp chữ. Lorem Ipsum đã trở thành văn bản giả chuẩn của ngành công nghiệp này kể từ những năm 1500, khi một thợ in vô danh lấy một galley chữ và xáo trộn nó để tạo ra một cuốn sách mẫu chữ.\n\nLorem Ipsum là gì?\n\n    Lorem Ipsum chỉ đơn giản là văn bản giả của ngành công nghiệp in ấn và sắp chữ. Lorem Ipsum đã trở thành văn bản giả chuẩn của ngành công nghiệp này kể từ những năm 1500, khi một thợ in vô danh lấy một galley chữ và xáo trộn nó để tạo ra một cuốn sách mẫu chữ. Nó không chỉ tồn tại trong năm thế kỷ, mà còn vượt qua cả bước nhảy vọt vào sắp chữ điện tử, về cơ bản vẫn không thay đổi. Nó đã trở nên phổ biến vào những năm 1960 với việc phát hành các tờ Letraset chứa các đoạn văn Lorem Ipsum, và gần đây hơn là với phần mềm xuất bản trên máy tính để bàn như Aldus PageMaker bao gồm các phiên bản của Lorem Ipsum.\n\nTại sao chúng ta sử dụng nó?\n\n   Một sự thật đã được chứng minh từ lâu là người đọc sẽ bị phân tâm bởi nội dung dễ đọc của một trang khi nhìn vào bố cục của nó. Mục đích của việc sử dụng Lorem Ipsum là nó có sự phân bổ các chữ cái ít nhiều bình thường, trái ngược với việc sử dụng 'Nội dung ở đây, nội dung ở đây', khiến nó trông giống như tiếng Anh dễ đọc. Nhiều gói xuất bản trên máy tính để bàn và trình chỉnh sửa trang web hiện sử dụng Lorem Ipsum làm văn bản mẫu mặc định của họ và khi tìm kiếm 'lorem ipsum', bạn sẽ khám phá ra nhiều trang web vẫn còn trong giai đoạn trứng nước. Nhiều phiên bản khác nhau đã phát triển qua nhiều năm, đôi khi là vô tình, đôi khi là cố ý (thêm vào sự hài hước và những thứ tương tự).\n\nNó bắt nguồn từ đâu?\n\n   Trái với quan niệm phổ biến, Lorem Ipsum không chỉ đơn thuần là văn bản ngẫu nhiên. Nó bắt nguồn từ một tác phẩm văn học La-tinh cổ điển từ năm 45 trước Công nguyên, khiến nó có tuổi đời hơn 2000 năm. Richard McClintock, một giáo sư tiếng Latin tại Cao đẳng Hampden-Sydney ở Virginia, đã tra cứu một trong những từ tiếng Latin khó hiểu nhất, consectetur, từ một đoạn văn Lorem Ipsum, và khi xem xét các trích dẫn của từ này trong văn học cổ điển, đã phát hiện ra nguồn gốc không thể chối cãi. Lorem Ipsum xuất phát từ các phần 1.10.32 và 1.10.33 của 'de Finibus Bonorum et Malorum' (Những điều cực đoan của Thiện và Ác) của Cicero, được viết vào năm 45 trước Công nguyên. Cuốn sách này là một chuyên luận về lý thuyết đạo đức, rất phổ biến trong thời kỳ Phục hưng. Dòng đầu tiên của Lorem Ipsum, 'Lorem ipsum dolor sit amet..', xuất phát từ một dòng trong phần 1.10.32.\n\n   Đoạn văn chuẩn của Lorem Ipsum được sử dụng từ những năm 1500 được sao chép bên dưới dành cho những ai quan tâm. Các phần 1.10.32 và 1.10.33 từ 'de Finibus Bonorum et Malorum' của Cicero cũng được sao chép theo đúng bản gốc, kèm theo phiên bản tiếng Anh từ bản dịch năm 1914 của H. Rackham.\n\nTôi có thể lấy ở đâu?\n\n   Có nhiều phiên bản khác nhau của đoạn văn Lorem Ipsum, nhưng phần lớn đã bị thay đổi ở một số dạng, bằng cách thêm yếu tố hài hước hoặc các từ ngẫu nhiên trông thậm chí không đáng tin chút nào. Nếu bạn định sử dụng một đoạn văn Lorem Ipsum, bạn cần đảm bảo không có bất kỳ điều gì đáng xấu hổ ẩn giấu ở giữa văn bản. Tất cả các trình tạo Lorem Ipsum trên Internet có xu hướng lặp lại các đoạn được xác định trước khi cần thiết, khiến đây trở thành trình tạo thực sự đầu tiên trên Internet. Nó sử dụng một từ điển gồm hơn 200 từ tiếng Latin, kết hợp với một số ít cấu trúc câu mẫu, để tạo ra Lorem Ipsum trông hợp lý. Do đó, Lorem Ipsum được tạo ra luôn không có sự lặp lại, thêm yếu tố hài hước hoặc các từ không đặc trưng, ​​v.v."
      },
      {
        "title": "Java OOPs Concepts",
        "date": "07/05/2023",
        "image": "assets/images/java2.jpg",
        "category": "Java Object Class",
        "content":"   Lập trình Hướng Đối Tượng (OOP - Object-Oriented Programming) là một phương pháp lập trình tập trung vào các đối tượng, thay vì chỉ làm việc với các hàm và biến. Java, một trong những ngôn ngữ lập trình phổ biến nhất, sử dụng mô hình OOP, giúp lập trình viên tạo ra mã nguồn dễ bảo trì và tái sử dụng. Để hiểu rõ hơn về lập trình hướng đối tượng trong Java, chúng ta sẽ tìm hiểu những khái niệm cốt lõi sau:\n\n    Lớp và Đối Tượng:Lớp là một bản thiết kế hoặc khuôn mẫu để tạo ra đối tượng. Lớp xác định các thuộc tính (biến) và phương thức (hàm) mà các đối tượng thuộc lớp đó sẽ có.Đối tượng là một thực thể cụ thể được tạo ra từ lớp. Khi bạn tạo một lớp, nó không chiếm bộ nhớ cho đến khi bạn khởi tạo một đối tượng từ lớp đó.\n\n    Đóng Gói (Encapsulation):Đóng gói là khái niệm ẩn đi các chi tiết bên trong của đối tượng và chỉ công khai các chức năng cần thiết. Điều này được thực hiện thông qua các mã truy cập (như private, public, protected), giúp kiểm soát quyền truy cập vào các thuộc tính và phương thức của đối tượng.\n\n    Kế Thừa (Inheritance):Kế thừa cho phép một lớp con kế thừa các thuộc tính và phương thức từ một lớp cha. Điều này giúp tái sử dụng mã và dễ dàng mở rộng các lớp mới mà không phải viết lại toàn bộ mã. Lớp con có thể kế thừa hoặc ghi đè các phương thức của lớp cha.\n\n   Polymorphism (Đa Hình):Đa hình cho phép các đối tượng của các lớp khác nhau có thể được xử lý như cùng một kiểu đối tượng, nhờ vào phương thức chung được định nghĩa trong lớp cha. Điều này có thể thực hiện thông qua việc ghi đè phương thức (method overriding) hoặc nạp chồng phương thức (method overloading).\n\n    Trừu Tượng (Abstraction):Trừu tượng giúp che giấu những chi tiết phức tạp và chỉ hiển thị những gì cần thiết. Trong Java, trừu tượng được thực hiện thông qua lớp trừu tượng và giao diện. Lớp trừu tượng có thể chứa cả phương thức đã định nghĩa và chưa định nghĩa (phương thức trừu tượng).\n\n   Các khái niệm trên tạo nền tảng vững chắc để phát triển phần mềm bằng Java theo phương pháp OOP. Việc nắm vững OOP không chỉ giúp mã nguồn trở nên dễ hiểu và bảo trì hơn mà còn tăng tính tái sử dụng và khả năng mở rộng trong các dự án phần mềm."
      },
      {
        "title": "Java Switch",
        "date": "07/05/2023",
        "image": "assets/images/java3.jpg",
        "category": "Control Statements",
        "content":"   Câu lệnh switch trong Java là một cấu trúc điều kiện giúp kiểm tra giá trị của một biểu thức và thực hiện hành động phù hợp. Thay vì sử dụng nhiều câu lệnh if-else phức tạp, bạn có thể dùng switch để kiểm tra một giá trị duy nhất và chọn ra hành động tương ứng.\n\n    Cấu trúc cơ bản của switch gồm:\n\n    Biểu thức kiểm tra: Đây là giá trị bạn muốn kiểm tra, ví dụ như một số hoặc một ký tự.\n\n    Các trường hợp (case): Mỗi trường hợp đại diện cho một giá trị cụ thể mà bạn muốn so sánh với biểu thức kiểm tra. Nếu giá trị của biểu thức khớp với một trong các trường hợp, chương trình sẽ thực thi hành động tương ứng.\n\n    Mặc định (default): Đây là lựa chọn không bắt buộc, được sử dụng khi không có trường hợp nào khớp với biểu thức kiểm tra.\n\n   Ưu điểm:\n\n    Đơn giản: Câu lệnh switch giúp mã nguồn trở nên dễ hiểu hơn khi bạn cần kiểm tra nhiều giá trị khác nhau.\n\n   Hiệu quả: Switch giúp tránh việc lặp lại nhiều câu lệnh if-else, giảm độ phức tạp của mã nguồn.\n\n   Khi nào sử dụng:\n\n    Bạn nên sử dụng switch khi có nhiều điều kiện cần kiểm tra, và giá trị bạn kiểm tra là các giá trị rời rạc (chẳng hạn như các số hoặc ký tự).\n\n   Câu lệnh switch giúp viết mã nguồn ngắn gọn và dễ hiểu hơn, đặc biệt là khi làm việc với nhiều trường hợp khác nhau."
      },
      {
        "title": "First Java Program | Hello World Example",
        "date": "07/05/2023",
        "image": "assets/images/java4.jpg",
        "category": "Java Tutorial",
        "content":"   Khi bắt đầu học lập trình Java, chương trình đầu tiên mà bạn sẽ viết thường là chương trình 'Hello World'. Đây là một cách đơn giản và hiệu quả để làm quen với cú pháp cơ bản của Java và cách thức thực thi một chương trình.\n\n    Giải Thích Cấu Trúc:\n\n    Lớp (Class): Mỗi chương trình Java đều bắt đầu với một lớp. Lớp là nơi chứa mã nguồn chính và có tên giống với tên tệp.\n\n   Phương thức main: Đây là điểm bắt đầu khi bạn chạy một chương trình Java. Phương thức main là phương thức đầu tiên được gọi khi chương trình được thực thi.\n\n   Câu lệnh System.out.println: Câu lệnh này dùng để in thông điệp ra màn hình console. Trong ví dụ này, nó sẽ in ra 'Hello World'.\n\n    Lý Do 'Hello World' Quan Trọng:\n\n   Cơ bản: Chương trình này giúp bạn làm quen với cách cấu trúc một chương trình Java.\n\n   Dễ hiểu: Đây là một ví dụ đơn giản để bạn có thể nhanh chóng bắt đầu mà không cần hiểu quá nhiều chi tiết phức tạp.\n\n   Ưu Điểm:\n\n    Khởi đầu dễ dàng: Đối với người mới bắt đầu, chương trình 'Hello World' là một bước khởi đầu dễ dàng để hiểu cách Java hoạt động.\n\n   Cách thức thực thi: Bạn sẽ học được cách biên dịch và chạy chương trình Java lần đầu tiên, cũng như cách sử dụng các công cụ như IDE (ví dụ: NetBeans, Eclipse).\n\n    Chương trình 'Hello World' chính là bước khởi đầu quan trọng giúp bạn làm quen với Java và chuẩn bị cho các chương trình phức tạp hơn trong tương lai."
      },
      {
        "title": "History of Java",
        "date": "07/05/2023",
        "image": "assets/images/java5.jpg",
        "category": "Java Tutorial",
        "content":"   Java được phát triển vào đầu những năm 1990 bởi Sun Microsystems, với tên ban đầu là Oak. Mục tiêu của Java là tạo ra một ngôn ngữ chạy trên nhiều nền tảng mà không cần thay đổi mã nguồn. Năm 1995, Java chính thức ra mắt công chúng với thông điệp “Write Once, Run Anywhere” (WORA), cho phép chạy chương trình trên bất kỳ hệ điều hành nào.\n\n    Phiên bản Java 1.0 ra mắt năm 1996, nhanh chóng được ứng dụng trong phần mềm doanh nghiệp và web. Trong suốt những năm 2000, Java trở thành ngôn ngữ chính cho phát triển ứng dụng di động và doanh nghiệp. Vào năm 2009, Oracle mua lại Sun Microsystems và tiếp tục phát triển Java.\n\n    Ngày nay, Java vẫn là ngôn ngữ phổ biến, đặc biệt trong các ứng dụng doanh nghiệp, di động (Android), và hệ thống phân tán. Với các tính năng hiện đại như Lambda và Streams API, Java tiếp tục giữ vững vị thế của mình trong ngành công nghệ."
      }

    ],
    "JavaScript": [
      {
        "title": "Async/await là gì? Async/await trong JavaScript",
        "date": "05/06/2023",
        "image": "assets/images/javas1.jpg",
        "category": "JavaScript Async/await",
        "content": "    Trong thế giới lập trình JavaScript, khi nhắc đến các thao tác bất đồng bộ (asynchronous), ta thường gặp những vấn đề như callback hell hay khó khăn trong việc quản lý luồng dữ liệu. Trước đây, **Promises** đã được giới thiệu như một giải pháp giúp viết mã bất đồng bộ rõ ràng hơn. Tuy nhiên, đến khi **async/await** xuất hiện trong ES2017, lập trình bất đồng bộ trở nên đơn giản, gọn gàng và dễ đọc hơn bao giờ hết.\n\n    `Async/await` là cú pháp được sử dụng để xử lý các thao tác bất đồng bộ. Từ khóa `async` được dùng để khai báo một hàm bất đồng bộ, và một hàm như vậy luôn trả về một **Promise**. Bên cạnh đó, từ khóa `await` chỉ được sử dụng bên trong các hàm được khai báo với `async`, giúp tạm dừng việc thực thi cho đến khi Promise được hoàn thành và trả về kết quả.\n\nVí dụ, nếu bạn muốn lấy dữ liệu từ một API, bạn có thể sử dụng async/await như sau:\n\nasync function fetchData() {\ntry {\n  let response = await fetch('https://api.example.com/data');\nlet data = await response.json();\nconsole.log(data);\n } catch (error) {\n console.error('Có lỗi xảy ra:', error);\n}\n}\n\n   Ở đây, `await` sẽ đợi cho đến khi `fetch` hoàn thành và trả về kết quả, giúp bạn viết mã theo cách tuyến tính giống như mã đồng bộ. Đoạn mã trên dễ đọc và bảo trì hơn so với việc sử dụng Promise thuần.\n\n   Nếu so sánh giữa việc dùng Promise và async/await, bạn sẽ thấy rằng async/await giúp mã nguồn trở nên ngắn gọn và rõ ràng hơn rất nhiều. Chẳng hạn, với cùng một nhiệm vụ, đoạn mã dùng Promise có thể như sau:\n\nfunction fetchData() {\nfetch('https://api.example.com/data')\n.then(response => response.json())\n.then(data => console.log(data))\n.catch(error => console.error('Có lỗi xảy ra:', error));\n}\n\n   Dễ thấy rằng khi dùng async/await, chúng ta tránh được tình trạng lồng ghép nhiều hàm callback, giúp mã trở nên dễ hiểu hơn.\n\n    Khi sử dụng async/await, bạn cần lưu ý một số điểm:\n\n   1. `await` chỉ hoạt động bên trong hàm `async`. Nếu bạn cố gắng sử dụng `await` ngoài hàm async, JavaScript sẽ báo lỗi.\n\n   2. Nên kết hợp với `try...catch` để xử lý lỗi, tránh làm chương trình dừng đột ngột khi gặp vấn đề.\n\n   3. Khi cần thực hiện nhiều thao tác bất đồng bộ cùng lúc, hãy cân nhắc sử dụng `Promise.all` để tối ưu hiệu suất thay vì chờ từng thao tác với `await`.\n\n   Tóm lại, async/await là một công cụ vô cùng hữu ích trong việc viết mã bất đồng bộ, giúp cho mã nguồn trở nên ngăn nắp và logic hơn. Bằng cách sử dụng async/await đúng cách, bạn có thể giảm thiểu sai sót và tăng khả năng bảo trì cho chương trình của mình."
      },
    {
        "title": "Microtasks là gì? Microtasks trong JavaScript",
        "date": "05/06/2023",
        "image": "assets/images/javas2.jpg",
        "category": "JavaScript Microtasks",
        "content": "    Microtasks trong JavaScript có thể được hiểu là những tác vụ nhỏ, được xử lý ngay sau khi một đoạn mã đang thực thi hoàn tất, nhưng trước khi trình duyệt thực hiện bất kỳ tác vụ nào khác, như rendering giao diện hoặc xử lý sự kiện. Các microtasks chủ yếu bao gồm các lời gọi callback từ các promise, như Promise.then(), Promise.catch(), Promise.finally(), hoặc những lời gọi queueMicrotask().\n\n    Lợi ích của microtasks là giúp duy trì tính đồng bộ trong các tác vụ bất đồng bộ (asynchronous), giúp đảm bảo rằng các thay đổi trạng thái (như cập nhật giá trị promise) được xử lý nhanh chóng mà không phải chờ đợi các tác vụ khác. Do microtasks có mức độ ưu tiên cao hơn macrotasks (như setTimeout, setInterval), chúng sẽ được thực thi trước, giúp giảm độ trễ trong các tác vụ bất đồng bộ."
    },
    {
        "title": "Các promise API trong JavaScript",
        "date": "05/06/2023",
        "image": "assets/images/javas4.jpg",
        "category": "JavaScript API",
        "content": "    Các Promise API trong JavaScript cung cấp những công cụ mạnh mẽ để quản lý các tác vụ bất đồng bộ và dễ dàng xử lý các kết quả của chúng. Dưới đây là các API và cách chúng hoạt động:\n\n    Promise.resolve(value): Tạo ra một Promise đã được giải quyết ngay lập tức với giá trị value. Nếu giá trị này là một Promise, Promise mới sẽ 'hờ'cho đến khi Promise ban đầu hoàn thành.\n\n    Promise.reject(reason): Tạo ra một Promise đã bị từ chối ngay lập tức với lý do reason. Đây là cách nhanh chóng để trả về lỗi từ một Promise khi có vấn đề xảy ra.\n\n    Promise.all(iterable): Nhận một iterable chứa các Promise và trả về một Promise mới. Promise này sẽ thành công khi tất cả các Promise trong iterable hoàn thành, hoặc bị từ chối nếu bất kỳ Promise nào bị lỗi.\n\n   Promise.allSettled(iterable): Trả về một Promise mới khi tất cả các Promise trong iterable đã hoàn thành, dù là thành công hay thất bại. Điều này giúp bạn có cái nhìn toàn diện về tất cả các tác vụ bất đồng bộ mà không cần quan tâm đến việc chúng thành công hay thất bại.\n\n   Promise.race(iterable): Trả về một Promise mới mà có trạng thái của Promise đầu tiên trong iterable hoàn thành, dù thành công hay thất bại. Điều này rất hữu ích khi bạn muốn xử lý kết quả từ một tác vụ bất đồng bộ ngay khi có kết quả đầu tiên.\n\n   Promise.any(iterable): Trả về một Promise mới sẽ thành công khi ít nhất một Promise trong iterable thành công. Nếu tất cả các Promise đều bị từ chối, Promise trả về sẽ bị từ chối.\n\n   Promise.finally(onFinally): Được sử dụng để thêm một hàm callback sẽ luôn được thực thi khi Promise đã được xử lý xong, bất kể thành công hay thất bại. Điều này có thể hữu ích khi bạn cần thực hiện công việc dọn dẹp như đóng kết nối, giải phóng tài nguyên, hoặc cập nhật giao diện, mà không cần quan tâm đến kết quả của Promise.\n\n    Những Promise API này mang lại khả năng xử lý linh hoạt và mạnh mẽ cho các tác vụ bất đồng bộ, cho phép lập trình viên dễ dàng quản lý và điều phối nhiều Promise đồng thời trong một ứng dụng."
    },
    {
        "title": "Xử lý lỗi với promise trong JavaScript",
        "date": "05/06/2023",
        "image": "assets/images/javas5.jpg",
        "category": "JavaScript Tutorial",
        "content": "    Xử lý lỗi với Promise trong JavaScript giúp đảm bảo chương trình hoạt động ổn định khi có sự cố xảy ra. Để xử lý lỗi, bạn có thể sử dụng phương thức `.catch()` được gọi sau `.then()`. Khi một lỗi xuất hiện trong quá trình thực thi Promise, `.catch()` sẽ được kích hoạt và nhận vào một hàm xử lý lỗi. Ngoài ra, khi sử dụng `async/await`, bạn nên dùng khối `try...catch` để bao quanh các thao tác bất đồng bộ nhằm bắt và xử lý lỗi một cách gọn gàng. Điều này giúp mã nguồn trở nên rõ ràng và dễ bảo trì hơn.\n\nVí dụ, với Promise thuần, bạn có thể xử lý lỗi như sau:\n   fetch('https://api.example.com/data\n   .then(response => response.json())\n    .then(data => console.log(data))\n    .catch(error => console.error('Có lỗi xảy ra:', error));\n\nCòn khi dùng `async/await`, bạn nên đặt các thao tác bên trong khối `try...catch` như sau:\n\nasync function fetchData() {\n try {\n   let response = await fetch('https://api.example.com/data');\n   data = await response.json();\n  .log(data);\n   } catch (error) {\n   .error('Có lỗi xảy ra:', error);\n    }\n   }"
    }
    ]
  }
  